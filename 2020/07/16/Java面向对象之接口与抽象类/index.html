<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java面向对象之接口与抽象类 | ZhangLichao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="张丽超个人博客" />
  
  <meta name="description" content="Java之接口（一）距离上篇已经过了好久啦，主要是临近期末，忙着复习，接口方面也看了好多天，查看了很多资料，层次不齐，最终查看了官方文档对于interface的介绍，才逐渐清晰一些。但是，毕竟是英文，看起来还是相对有些费劲的，但是看完一整篇下来，产生了一种英文进步飞快的错觉哈哈哈哈。 话不多说，直接给一个形象生动的例子：  There are a number of situations in s">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面向对象之接口与抽象类">
<meta property="og:url" content="https://zhanglc1998.github.io/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/index.html">
<meta property="og:site_name" content="ZhangLichao">
<meta property="og:description" content="Java之接口（一）距离上篇已经过了好久啦，主要是临近期末，忙着复习，接口方面也看了好多天，查看了很多资料，层次不齐，最终查看了官方文档对于interface的介绍，才逐渐清晰一些。但是，毕竟是英文，看起来还是相对有些费劲的，但是看完一整篇下来，产生了一种英文进步飞快的错觉哈哈哈哈。 话不多说，直接给一个形象生动的例子：  There are a number of situations in s">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.ax1x.com/2020/01/02/lYwpes.png">
<meta property="article:published_time" content="2020-07-16T03:08:44.000Z">
<meta property="article:modified_time" content="2021-10-17T01:24:17.393Z">
<meta property="article:author" content="ZhangLichao">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/01/02/lYwpes.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">ZhangLichao&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>首页</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>归档</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>关于我</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/touxiang.jpg" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        ZhangLichao&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个专注 WEB 开发的技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a   ">
                            <i class="fa fa-qq fa-2x"></i></a>
                    
                        <a   ">
                            <i class="fa fa-weixin fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Java面向对象之接口与抽象类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      Java面向对象之接口与抽象类
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-07-16
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="Java之接口（一）"><a href="#Java之接口（一）" class="headerlink" title="Java之接口（一）"></a>Java之接口（一）</h1><p>距离上篇已经过了好久啦，主要是临近期末，忙着复习，接口方面也看了好多天，查看了很多资料，层次不齐，最终查看了官方文档对于<code>interface</code>的介绍，才逐渐清晰一些。但是，毕竟是英文，看起来还是相对有些费劲的，但是看完一整篇下来，产生了一种英文进步飞快的错觉哈哈哈哈。</p>
<p>话不多说，直接给一个形象生动的例子：</p>
<blockquote>
<p>There are a number of situations in software engineering when it is important for disparate groups of programmers to agree to a “<strong>contract</strong>“ that spells out how their software interacts. Each group should be able to write their code without any knowledge of how the other group’s code is written. Generally speaking, interfaces are such contracts.</p>
</blockquote>
<p>大概的意思就是，开发的时候，每个小组只需认可一份软件交互的“<strong>契约</strong>”，不需要关注其他小组的代码是怎么写的。我们将要学习的接口，就是充当这个“契约”的角色。其实也挺好理解的，面向对象的口号不就是高内聚低耦合嘛，接口的出现很好地让规范和实现分离，从而大大降低了各组件的耦合，大大提高了可扩展性和可维护性。<br>再接着说，<strong>接口是一种规范</strong>，是其他组成部分都必须遵守的，<strong>是一组公共的方法</strong>，和我们之前谈到的抽象类真的很像，它们达到的功能其实也差不多，两者差别我们之后会详细分析。接下来应该会分许多个部分探究接口，敬请期待。</p>
<h2 id="接口中的定义格式"><a href="#接口中的定义格式" class="headerlink" title="接口中的定义格式"></a>接口中的定义格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.pac19;</span><br><span class="line"><span class="comment">//Output.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Summerday</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Output</span> </span>&#123;</span><br><span class="line">    <span class="comment">//常量: public static final int MAX_CACHE_LINE=50;</span></span><br><span class="line">    <span class="keyword">int</span> MAX_CACHE_LINE = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">//普通方法: public abstract void out();</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="comment">//默认方法: public default void print(String...msgs)</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String...msgs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String msg:msgs)&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;default test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态方法：public static String staticTest()</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">staticTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;the static method in interface&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//!false:static String staticTest1();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>interface</code>关键字表示接口，可以把接口看作是特殊的类，<strong>命名规范</strong>类似。而且，一个Java源文件中最多只能有一个public接口，且Java源文件名应该和public接口名相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">interface</span> [接口名] <span class="keyword">extends</span> [父接口1],[父接口2] </span>&#123;</span><br><span class="line">    <span class="comment">//零到多个常量定义</span></span><br><span class="line">    <span class="comment">//零到多个抽象方法定义</span></span><br><span class="line">    <span class="comment">//零到多个默认方法和类方法定义</span></span><br><span class="line">    <span class="comment">//零到多个内部类、接口、枚举定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>[修饰符]可以是public，也可以是缺省，缺省就默认采用包权限。</p>
</li>
<li><p>接口可以继承多个接口，以逗号分隔，不能继承类。</p>
</li>
<li><p><strong>Java8之前并不允许默认方法和类方法的定义</strong>，加强之后就允许了。</p>
</li>
<li><p>接口里<strong>不能有构造器(不能创建对象）</strong>和初始化块。</p>
</li>
<li><p>接口中的成员（静态变量、方法等）默认都是public修饰的，所以加不加public没啥区别，但也只有这两种选择，因为毕竟规范就是需要让别人知道并遵循的。</p>
</li>
</ul>
<h2 id="接口中的成员变量"><a href="#接口中的成员变量" class="headerlink" title="接口中的成员变量"></a>接口中的成员变量</h2><p>接口中只能有静态变量，不能有实例变量，因为它<strong>不能创建对象</strong>，也就不能有实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量: public static final int MAX_CACHE_LINE=50;</span></span><br><span class="line">    <span class="keyword">int</span> MAX_CACHE_LINE = <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口中的域默认且只能是以<code>public static final</code>修饰的静态常量，所以这几个修饰词可以省略，如上。</li>
<li>既然<strong>没有构造器和初始化块</strong>，那么定义静态变量时就应该给他初始化赋值，不然会报错哦。</li>
<li>静态常量，仅有一份，且不能修改。</li>
</ul>
<h2 id="接口中的普通方法"><a href="#接口中的普通方法" class="headerlink" title="接口中的普通方法"></a>接口中的普通方法</h2><p>Java8之前，接口中只允许声明抽象方法，Java8之后做了增强，增加了对默认方法和类方法声明的允许。这里，暂且除那俩之外的称作普通方法，也就是<strong>抽象方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通方法: public abstract void out();</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">(String msg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>类似的，接口中的普通方法既然是抽象方法，当然默认有<code>abstract</code>关键字了，上面提到接口中的成员都是<code>public</code>修饰的，所以普通方法默认<code>public abstract</code>，同样的，可以省略不写。</li>
<li>很显然，抽象方法不能有具体的方法体实现。</li>
</ul>
<h2 id="接口中的默认方法"><a href="#接口中的默认方法" class="headerlink" title="接口中的默认方法"></a>接口中的默认方法</h2><p>作为<strong>Java8之后增加的默认方法</strong>，所谓存在即合理，它的出现一定解决了一些棘手的问题，但是目前我对此理解还不够透彻，在之后的学习中，慢慢理解，再做总结。我们先了解它的定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认方法: public default void print(String...msgs)</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String...msgs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String msg:msgs)&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//!false:default void test1();</span></span><br><span class="line"><span class="comment">//extension method should have a body</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认方法以<code>default</code>关键字修饰，而不是<code>static</code>。</li>
<li>默认方法在接口中<strong>必须有具体实现</strong>，否则会报错。</li>
<li>默认方法是可以在实现类中<strong>被重写</strong>的。</li>
</ul>
<h2 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h2><p>同样的，他和默认方法都是新引进的宝贝，具体优点还是之后再做分析。先看一手定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法：public static String staticTest()</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">staticTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;the static method in interface&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//!false:static String staticTest1();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>静态方法以<code>static</code>关键字修饰，且不能被重写。</li>
<li>一样的，接口中的静态方法也需要有具体的方法实现，不然就错啦。</li>
<li>静态方法只属于接口,只能在接口中调用静态方法，并不能在接口实现类中调用方法。就是说只能以<code>接口.静态方法</code>的格式调用接口中的静态方法。</li>
</ul>
<p>[toc]</p>
<h1 id="Java面向对象之接口（二）"><a href="#Java面向对象之接口（二）" class="headerlink" title="Java面向对象之接口（二）"></a>Java面向对象之接口（二）</h1><ul>
<li>我们之前谈到，Java作为面向对象的语言，并不支持多继承。但是Java中的接口可以实现多继承即会出现：<code>interface A extends InterfaceC,InterfaceD</code>的形式，在一定程度上增加了灵活性。不仅这样，Java中的类也可以<strong>实现</strong>(implements)多个接口，间接地达到所继承的功能，成为<strong>“多实现”</strong>。</li>
<li>其实，当我们了解了接口，会发现这完全是合理的。为什么这么说呢？在Java中如果你继承两个类，两个类中有同名但不同行为的方法，你在派生类中是不是不知道用哪个，是不是很头疼。但是接口就不一样，我们知道，<strong>接口中的抽象方法或者默认方法最终会被实现类定义</strong>（<u>如果两个方法方法签名相同但是返回类型不同，这时在实现方法时就需要返回两者的公共子类型</u>）所以不存在选择上的困难。接下来，我们慢慢来分析接口继承中可能会出现的问题。</li>
</ul>
<h2 id="接口定义与实现接口"><a href="#接口定义与实现接口" class="headerlink" title="接口定义与实现接口"></a>接口定义与实现接口</h2><ul>
<li><code>extends</code>关键字的出现一定代表着一种继承，或者说是一种扩展，就是子接口可以获得父接口中的成员。注意：<strong>接口可以继承接口，但是不能够继承类</strong>哦。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Countable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> NUM = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Edible</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;Edible&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howToEat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CreatureDoing</span> <span class="keyword">extends</span> <span class="title">Edible</span>, <span class="title">Countable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">howToSleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这时让CreatureDoing接口继承Edible和Countable两个接口，用逗号隔开，可以验证，子接口中获得了父接口的成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(CreatureDoing.name);<span class="comment">//Edible</span></span><br><span class="line">System.out.println(CreatureDoing.NUM);<span class="comment">//50</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>接口无法用于创建实例，所以接口需要被类实现</strong>，这时就需要用到<code>implements</code>关键字。格式如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类实现多个接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类 <span class="keyword">implements</span> 接口1，接口2</span>&#123;&#125;</span><br><span class="line"><span class="comment">//类继承某类，且实现多个接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类1 <span class="keyword">extends</span> 类2 <span class="keyword">implements</span> 接口1，接口2</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接口的实现和继承类似，可以获得接口中的成员变量和方法，但是需要注意的是，<strong>实现类中需要明确给出所实现的接口的所有抽象方法</strong>，否则该实现类需要定义为抽象类。这句话，有点绕，我们知道接口中的抽象方法是需要实现类去实现的，我们又说了接口可以继承接口，类可以实现多个接口。那么，如果接口A中有一个抽象方法method1,接口B继承接口A，有一个抽象方method2，类C继承了这两个接口，就要求C在类中实现这两个抽象方法，这就叫实现所有的抽象方法。</p>
</li>
<li><p>还有一个点就是，实现方法其实就是重写接口中的抽象方法啦，所以必须要声明实现方法为<strong>public</strong>的，不然不满足重写的要求呢。</p>
</li>
</ul>
<h2 id="接口与多态"><a href="#接口与多态" class="headerlink" title="接口与多态"></a>接口与多态</h2><ul>
<li>可以把接口当作一种引用数据类型，可以直接用接口调用其成员，如上<code>Creature.NUM</code>。</li>
<li>不仅如此，<strong>接口可以声明引用类型的变量指向其实现类的对象</strong>，这类似于让父类变量指向子类对象，是多态性的很好体现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口也实现了多态</span></span><br><span class="line">Edible[] ediblesArray = <span class="keyword">new</span> Edible[]&#123;<span class="keyword">new</span> Chicken(), <span class="keyword">new</span> Orange()&#125;;</span><br><span class="line"><span class="keyword">for</span> (Edible edible : ediblesArray) &#123;</span><br><span class="line">    edible.howToEat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口是否继承于Object"><a href="#接口是否继承于Object" class="headerlink" title="接口是否继承于Object"></a>接口是否继承于Object</h2><ul>
<li>在书上看到一句话：<strong>所有的接口类型的引用变量都可以直接赋值给Object类型的变量</strong>，于是我产生疑惑，既然这样是不是意味着接口类型也是继承于Object类呢？<br>于是我进行了尝试，我用接口类型的变量调用了Object类的方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(cd.hashCode());</span><br></pre></td></tr></table></figure>

<ul>
<li>让我震惊的是，可以调用成功。但是我始终心存疑惑，于是我展开了漫长的资料搜索，网络上的资料参差不齐，最终在这里贴一下我在stack overflow上看到的觉得比较靠谱的答案：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6056124/do-interfaces-inherit-from-object-class-in-java?r=SearchResults">Do interfaces inherit from Object class in java</a></li>
</ul>
<p><img src="https://s2.ax1x.com/2020/01/02/lYwpes.png" alt="lYwpes.png"></p>
<ul>
<li>接口和类始终是并行的关系，它们都代表着一种引用数据类型，所有类都继承于Obejct类，但接口并不是。接口类型变量之所以能够调用Object类中的方法，是因为<u>接口中隐含了一套和Object类方法签名完全相同的方法</u>，如果不这样子的话，不能够编译成功。</li>
<li>而接口类型的引用变量可以直接赋值给Object类型的变量，也可以这么理解：接口最终都是需要实现类去实现的，引用变量指向实现类的实例，而实现类都是Object的子类，所以是完全合理的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.pac19;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Summerday</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEdible</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Countable.NUM);</span><br><span class="line">        System.out.println(Edible.name);</span><br><span class="line">        <span class="comment">//接口 不能用于创建实例，但是可以声明引用类型变量指向其实现类的对象</span></span><br><span class="line">        CreatureDoing cd = <span class="keyword">new</span> Chicken();</span><br><span class="line">        System.out.println(cd.hashCode());</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//接口也实现了多态</span></span><br><span class="line">        Edible[] ediblesArray = <span class="keyword">new</span> Edible[]&#123;<span class="keyword">new</span> Chicken(), <span class="keyword">new</span> Orange()&#125;;</span><br><span class="line">        <span class="keyword">for</span> (Edible edible : ediblesArray) &#123;</span><br><span class="line">            edible.howToEat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Countable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> NUM = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Edible</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;Edible&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">howToEat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//redundant 多余的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口继承接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CreatureDoing</span> <span class="keyword">extends</span> <span class="title">Edible</span>, <span class="title">Countable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">howToSleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Edible</span>, <span class="title">CreatureDoing</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现Edible中的howToEat方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howToEat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡要烤着吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Animal中的call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咯咯哒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Creature中的howToSleep方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howToSleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;呼呼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Edible</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howToEat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;橘子要剥皮吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>本文若有叙述不当之处，欢迎评论区留言交流！</p>
<p>参考链接：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6056124/do-interfaces-inherit-from-object-class-in-java?r=SearchResults">https://stackoverflow.com/questions/6056124/do-interfaces-inherit-from-object-class-in-java?r=SearchResults</a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2">https://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2</a></p>
<h1 id="Java之抽象类与抽象方法"><a href="#Java之抽象类与抽象方法" class="headerlink" title="Java之抽象类与抽象方法"></a>Java之抽象类与抽象方法</h1><h2 id="抽象概念"><a href="#抽象概念" class="headerlink" title="抽象概念"></a>抽象概念</h2><p>本篇关键词是<strong>抽象</strong>，那么何为抽象？百度百科告诉我们，抽象就是概括具体事务共同的方面、本质属性等，而将个别的方面、属性等舍弃的思维过程。在Java里，也就是<strong>把各个具体的类中共有的方法提取出来，放到基类之中，而基类并不需要了解子类中该方法具体是怎么实现的</strong>，这个基类就是所谓的<strong>抽象类</strong>，这些不需要知道具体实现方式的方法就是<strong>抽象方法</strong>。</p>
<blockquote>
<p>抽象类体现<strong>模板模式</strong>的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会大致保留抽象类的行为方式。</p>
</blockquote>
<h2 id="抽象类与方法"><a href="#抽象类与方法" class="headerlink" title="抽象类与方法"></a>抽象类与方法</h2><p>让我们结合代码，好好地分析一波：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.pac18;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Summerday</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*抽象是很有用的重构工具，能够让共有的方法沿着继承层次向上移动。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象类中的初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape.instance initializer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象类中的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="comment">//抽象类中可以有静态方法及属性。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name=<span class="string">&quot;形状&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的static方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算周长，但是并不知道具体细节的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calPerimeter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回形状的抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//[修饰符] abstract 返回类型 方法名();</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象类中的构造器，用于被继承</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape.Shape&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象类中的普通实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String color, <span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getColor() + <span class="string">&quot;圆形&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果从一个抽象类继承，并创建该新类的对象，就必须给基类的所有抽象方法提供定义。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape.output();</span><br><span class="line">        <span class="comment">//Shape是抽象类，不能创建Shape类的对象</span></span><br><span class="line">        <span class="comment">//但是可以让Shape类的引用变量指向其子类的对象</span></span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> Shape[]&#123;<span class="keyword">new</span> Circle(<span class="string">&quot;红色&quot;</span>, <span class="number">5</span>), <span class="keyword">new</span> Rectangle(<span class="string">&quot;绿色&quot;</span>, <span class="number">6</span>, <span class="number">6</span>)&#125;;</span><br><span class="line">        <span class="keyword">for</span> (Shape p : shapes) &#123;</span><br><span class="line">            </span><br><span class="line">            System.out.println(p.getType() + <span class="string">&quot;的周长为&quot;</span> + p.calPerimeter());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的构造器不是为了创建对象，而是供给子类继承的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(String color, <span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSquare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length == width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (length + width) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSquare()) <span class="keyword">return</span> getColor() + <span class="string">&quot;正方形&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> getColor() + <span class="string">&quot;长方形&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">父类的<span class="keyword">static</span>方法</span><br><span class="line">Shape.instance initializer</span><br><span class="line">Shape.Shape</span><br><span class="line">Shape.instance initializer</span><br><span class="line">Shape.Shape</span><br><span class="line">红色圆形的周长为<span class="number">31.41592653589793</span></span><br><span class="line">绿色正方形的周长为<span class="number">24.0</span></span><br></pre></td></tr></table></figure>

<p>顺着上面的例子，我们简单地分析一下，<strong>抽象类</strong>与<strong>抽象方法</strong>到底是啥？又需要注意些啥？</p>
<ul>
<li>首先定义了一个<strong>抽象类</strong>：Shape类。可以看到，抽象类由<code>abstract</code>关键字修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[修饰符] abstract class 类名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后再Shape类里定义了两个<strong>抽象方法</strong>（方法可以被重写，属性不可以，<strong>抽象是针对方法而言的</strong>）：<code>getType()</code>和<code>calPerimeter()</code>可以看出抽象方法声明时并没有定义方法体，因为基类中并不需要知道具体的实现方式是怎样，只要知道有这个方法就可以了。你创建一个圆形实例，具体如何算圆形的周长，在圆形类给出抽象方法的定义即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[修饰符] abstract 返回类型 方法名();</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calPerimeter</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getType</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><strong>如果子类从抽象父类继承而来，那么子类就必须重写父类的抽象方法，给出方法的具体实现形式</strong>。你的爸爸说你会算周长，你总得告诉大家周长怎么算吧。但是，如果<strong>子类中也重写父类的方法也声明为抽象</strong>的话，这时父类方法在子类中的实现也无效了。就好比，你说你也不知道怎么算周长，隔壁小王才是真的会。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getColor() + <span class="string">&quot;圆形&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>抽象类不能实例化</strong>，不能用new来调用抽象类构造器创建抽象类的实例。可以想象，既然是抽象的，创建它的实例就没多大意义，创建具体实现的子类的实例才能解决问题。</li>
<li><strong>抽象类可以用作一种数据类型，可以让抽象类的引用变量指向它的子类对象</strong>，很好理解，不这样的话，抽象带来的好处体现在哪呢。通过抽象类的引用变量调用抽象类中的方法，就能够根据动态绑定，在运行时根据引用对象的实际类型执行抽象方法的具体表现形式。</li>
<li>抽象类中是能够有具体实现的成员方法（实例方法和类方法），以及明确的成员属性（实例属性和类属性）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类中的实例方法，子类继承使用。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//抽象类中可以有静态方法和属性，类名.方法（属性）调用。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String name=<span class="string">&quot;形状&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;父类的static方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类中还可以有构造器，但是仅仅是为了<strong>供给子类继承使用</strong>，因为上面讲过，抽象类无法创建实例对象！！！(重点回顾：<u>子类无法继承父类构造器，只是单纯调用父类构造器的初始化代码，继承和调用是不一样的！！！</u>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Shape.Shape&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类中还有代码块和内部类，关于内部类之后将会学习，暂时就不举例了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//抽象类中的初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Shape.instance initializer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>一个类中如果有抽象方法，那么这个类也一定是抽象的</strong>。毕竟你的方法定义尚且都不完全，创建你的实例又有啥用呢。<strong>但是一个抽象类中可以没有抽象方法</strong>，只是单纯不让人创建它的实例对象。</p>
</li>
<li><p><strong>子类是抽象，父类也可以是具体的</strong>。如上，Object类是所有类的超类，它是具体的，我们定义的Shape类是可以抽象的。</p>
</li>
<li><p>抽象是实现多态的一种机制，那么不具备多态性的，就不能称之为多态。诸如private、static、final修饰的方法或构造器属于静态绑定，不具备多态性，不能作为抽象的修饰。</p>
</li>
</ul>
<p>本文是根据资料以及个人测试之后所得，若有错误或者理解不当之处，还望评论区指出，谢谢。</p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年10月17日 09:24</p>
        <p>原始链接： <a class="post-url" href="/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/" title="Java面向对象之接口与抽象类">https://zhanglc1998.github.io/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/</a></p>
        <footer>
            <a href="https://zhanglc1998.github.io">
                <img src="/images/touxiang.jpg" alt="ZhangLichao">
                ZhangLichao
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://zhanglc1998.github.io/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/&title=《Java面向对象之接口与抽象类》 — ZhangLichao&pic=images/java.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://zhanglc1998.github.io/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/&title=《Java面向对象之接口与抽象类》 — ZhangLichao&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://zhanglc1998.github.io/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java面向对象之接口与抽象类》 — ZhangLichao&url=https://zhanglc1998.github.io/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/&via=https://zhanglc1998.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://zhanglc1998.github.io/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://zhanglc1998.github.io/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Java%E4%B9%8B%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%80%EF%BC%89"><span class="post-toc-text">Java之接口（一）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="post-toc-text">接口中的定义格式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="post-toc-text">接口中的成员变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95"><span class="post-toc-text">接口中的普通方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="post-toc-text">接口中的默认方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="post-toc-text">接口中的静态方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="post-toc-text">Java面向对象之接口（二）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="post-toc-text">接口定义与实现接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="post-toc-text">接口与多态</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E4%BA%8EObject"><span class="post-toc-text">接口是否继承于Object</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Java%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="post-toc-text">Java之抽象类与抽象方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="post-toc-text">抽象概念</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="post-toc-text">抽象类与方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="post-toc-text">注意事项</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/07/16/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%BC%82%E5%90%8C/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          浅谈Java中接口与抽象类的异同
        
      </span>
    </a>
  
  
    <a href="/2020/07/16/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Java面向对象之多态</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 ZhangLichao<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://zhanglc1998.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/life/">life</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/Mysql/" style="font-size: 13.33px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/SpringBoot/" style="font-size: 13.33px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 20px;">SpringCloud</a> <a href="/tags/SpringMvc/" style="font-size: 10px;">SpringMvc</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/welcome/" style="font-size: 10px;">welcome</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>首页</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>归档</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>关于我</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/Mysql/" style="font-size: 13.33px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/SpringBoot/" style="font-size: 13.33px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 20px;">SpringCloud</a> <a href="/tags/SpringMvc/" style="font-size: 10px;">SpringMvc</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/welcome/" style="font-size: 10px;">welcome</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>