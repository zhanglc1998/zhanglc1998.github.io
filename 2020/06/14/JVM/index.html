<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JVM | ZhangLichao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="张丽超个人博客" />
  
  <meta name="description" content="JVM探究请你谈谈对JVM的理解? java8虚拟机和之前的变化更新什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析?JVM常用的调优参数有哪些?内存快照如何抓取? 怎么分析Domp文件 ? 知道吗?谈谈JVM中,类加载器你的认识? 1.jvm的位置 2.jvm的体系结构 3.类加载器 4.双亲委派机制虚拟机自带的加载器 启动类 (根) 加载器 扩展类加">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="https://zhanglc1998.github.io/2020/06/14/JVM/index.html">
<meta property="og:site_name" content="ZhangLichao">
<meta property="og:description" content="JVM探究请你谈谈对JVM的理解? java8虚拟机和之前的变化更新什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析?JVM常用的调优参数有哪些?内存快照如何抓取? 怎么分析Domp文件 ? 知道吗?谈谈JVM中,类加载器你的认识? 1.jvm的位置 2.jvm的体系结构 3.类加载器 4.双亲委派机制虚拟机自带的加载器 启动类 (根) 加载器 扩展类加">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/jvm位置.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/JVM体系结构.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/类加载器.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/pc寄存器.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/栈.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/栈堆方法区交互.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/三中JVm.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/堆1.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/堆2.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/堆永久区.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/引用计数法.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/复制算法.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/复制算法2.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/标记清除法.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/标记清除压缩法.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/JMM.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/1.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/JMM1.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/aba原型结果.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/阻塞队列.png">
<meta property="og:image" content="c:/Users/chenn-a/Desktop/图片/阻塞队列方法.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613224945385-1072836449.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614002358591-1764103391.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614002426565-1963789099.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614000329689-872917045.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614011044060-2111473950.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614105112553-1657649661.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614112107515-173627228.png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbW94aTE1OTc1My9MZWFybmluZ05vdGVzL3Jhdy9tYXN0ZXIvJUU2JUEwJUExJUU2JThCJTlCJUU5JTlEJUEyJUU4JUFGJTk1L0pVQy8xMF8lRTclQkElQkYlRTclQTglOEIlRTYlQjElQTAvaW1hZ2VzL2ltYWdlLTIwMjAwMzE3MTUyNTQxMjg0LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbW94aTE1OTc1My9MZWFybmluZ05vdGVzL3Jhdy9tYXN0ZXIvJUU2JUEwJUExJUU2JThCJTlCJUU5JTlEJUEyJUU4JUFGJTk1L0pVQy8xMF8lRTclQkElQkYlRTclQTglOEIlRTYlQjElQTAvaW1hZ2VzL2ltYWdlLTIwMjAwMzE3MTc1MjQxMDA3LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbW94aTE1OTc1My9MZWFybmluZ05vdGVzL3Jhdy9tYXN0ZXIvJUU2JUEwJUExJUU2JThCJTlCJUU5JTlEJUEyJUU4JUFGJTk1L0pVQy8xMF8lRTclQkElQkYlRTclQTglOEIlRTYlQjElQTAvaW1hZ2VzL2ltYWdlLTIwMjAwMzE3MTgyMDA0MjkzLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbW94aTE1OTc1My9MZWFybmluZ05vdGVzL3Jhdy9tYXN0ZXIvJUU2JUEwJUExJUU2JThCJTlCJUU5JTlEJUEyJUU4JUFGJTk1L0pVQy8xMF8lRTclQkElQkYlRTclQTglOEIlRTYlQjElQTAvaW1hZ2VzL2ltYWdlLTIwMjAwMzE3MTgzMjAyOTkyLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020051217395386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvb2tGb3JEcmVhbV8=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512174016258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvb2tGb3JEcmVhbV8=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="c:/Users/chenn-a/AppData/Roaming/Typora/typora-user-images/image-20210517105350856.png">
<meta property="og:image" content="c:/Users/chenn-a/AppData/Roaming/Typora/typora-user-images/image-20210517110144433.png">
<meta property="og:image" content="c:/Users/chenn-a/AppData/Roaming/Typora/typora-user-images/image-20210519090059980.png">
<meta property="og:image" content="c:/Users/chenn-a/AppData/Roaming/Typora/typora-user-images/image-20210519090304922.png">
<meta property="article:published_time" content="2020-06-14T01:53:56.000Z">
<meta property="article:modified_time" content="2021-10-16T08:06:33.930Z">
<meta property="article:author" content="ZhangLichao">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/chenn-a/Desktop/图片/jvm位置.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">ZhangLichao&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>首页</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>归档</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>关于我</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        ZhangLichao&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个专注 WEB 开发的技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a   ">
                            <i class="fa fa-qq fa-2x"></i></a>
                    
                        <a   ">
                            <i class="fa fa-weixin fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-JVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      JVM
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-06-14
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h1><p>请你谈谈对JVM的理解? java8虚拟机和之前的变化更新<br>什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析?<br>JVM常用的调优参数有哪些?<br>内存快照如何抓取? 怎么分析Domp文件 ? 知道吗?<br>谈谈JVM中,类加载器你的认识?</p>
<h1 id="1-jvm的位置"><a href="#1-jvm的位置" class="headerlink" title="1.jvm的位置"></a>1.jvm的位置</h1><p><img src="C:\Users\chenn-a\Desktop\图片\jvm位置.png" alt="jvm位置"></p>
<h1 id="2-jvm的体系结构"><a href="#2-jvm的体系结构" class="headerlink" title="2.jvm的体系结构"></a>2.jvm的体系结构</h1><p><img src="C:\Users\chenn-a\Desktop\图片\JVM体系结构.png" alt="JVM体系结构"></p>
<h1 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h1><p><img src="C:\Users\chenn-a\Desktop\图片\类加载器.png" alt="类加载器"></p>
<h1 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4.双亲委派机制"></a>4.双亲委派机制</h1><p>虚拟机自带的加载器</p>
<p>启动类 (根) 加载器</p>
<p>扩展类加载器</p>
<p>应用程序加载器</p>
<p>app—&gt;扩展类(ext) —-&gt; (启动类)根加载器(rt) —&gt;</p>
<p>1.类加载器收到类加载的请求<br>2.将这个请求向上委托给父类加载器去完成, 一直向上委托, 直到启动类加载器(根加载器rt)<br>3.启动类加载器检查是否能够加载当前这个类, 能够加载就结束了, 使用当前加载器,否则抛出异常,通知子类加载器进行加载.<br>4.重复步骤3.</p>
<h2 id="1-1-什么是双亲委派机制"><a href="#1-1-什么是双亲委派机制" class="headerlink" title="1.1 什么是双亲委派机制"></a>1.1 什么是双亲委派机制</h2><p>当某个类加载器需要加载某个<code>.class</code>文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</p>
<h2 id="1-2-类加载器的类别"><a href="#1-2-类加载器的类别" class="headerlink" title="1.2 类加载器的类别"></a>1.2 类加载器的类别</h2><h4 id="BootstrapClassLoader（启动类加载器）"><a href="#BootstrapClassLoader（启动类加载器）" class="headerlink" title="BootstrapClassLoader（启动类加载器）"></a>BootstrapClassLoader（启动类加载器）</h4><p><code>c++</code>编写，加载<code>java</code>核心库 <code>java.*</code>,构造<code>ExtClassLoader</code>和<code>AppClassLoader</code>。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作</p>
<h4 id="ExtClassLoader-（标准扩展类加载器）"><a href="#ExtClassLoader-（标准扩展类加载器）" class="headerlink" title="ExtClassLoader （标准扩展类加载器）"></a>ExtClassLoader （标准扩展类加载器）</h4><p><code>java</code>编写，加载扩展库，如<code>classpath</code>中的<code>jre</code> ，<code>javax.*</code>或者<br> <code>java.ext.dir</code> 指定位置中的类，开发者可以直接使用标准扩展类加载器。</p>
<h4 id="AppClassLoader（系统类加载器）"><a href="#AppClassLoader（系统类加载器）" class="headerlink" title="AppClassLoader（系统类加载器）"></a>AppClassLoader（系统类加载器）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java`编写，加载程序所在的目录，如`user.dir`所在的位置的`class</span><br></pre></td></tr></table></figure>

<h4 id="CustomClassLoader（用户自定义类加载器）"><a href="#CustomClassLoader（用户自定义类加载器）" class="headerlink" title="CustomClassLoader（用户自定义类加载器）"></a>CustomClassLoader（用户自定义类加载器）</h4><p><code>java</code>编写,用户自定义的类加载器,可加载指定路径的<code>class</code>文件</p>
<h2 id="1-3-源码分析"><a href="#1-3-源码分析" class="headerlink" title="1.3 源码分析"></a>1.3 源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先检查这个classsh是否已经加载过了</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// c==null表示没有加载，如果有父类的加载器则让父类加载器加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果父类的加载器为空 则说明递归到bootStrapClassloader了</span></span><br><span class="line">                        <span class="comment">//bootStrapClassloader比较特殊无法通过get获取</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果bootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-委派机制的流程图"><a href="#1-4-委派机制的流程图" class="headerlink" title="1.4 委派机制的流程图"></a>1.4 委派机制的流程图</h2><p><img src="https://upload-images.jianshu.io/upload_images/7634245-7b7882e1f4ea5d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="1-5-双亲委派机制的作用"><a href="#1-5-双亲委派机制的作用" class="headerlink" title="1.5 双亲委派机制的作用"></a>1.5 双亲委派机制的作用</h2><p>1、防止重复加载同一个<code>.class</code>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。<br> 2、保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.clas</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全</p>
<h1 id="5-沙箱安全机制"><a href="#5-沙箱安全机制" class="headerlink" title="5.沙箱安全机制"></a>5.沙箱安全机制</h1><h1 id="6-Native"><a href="#6-Native" class="headerlink" title="6.Native*"></a>6.Native*</h1><p>Native 关键字 调用 本地方法栈—-&gt; JNI (java Native Interface本地方法接口) 调用外部语言程序</p>
<h1 id="7-pc寄存器"><a href="#7-pc寄存器" class="headerlink" title="7.pc寄存器"></a>7.pc寄存器</h1><p><img src="C:\Users\chenn-a\Desktop\图片\pc寄存器.png" alt="pc寄存器"></p>
<h1 id="8-方法区"><a href="#8-方法区" class="headerlink" title="8.方法区"></a>8.方法区</h1><p>Method Area 方法区</p>
<p> 方法区是被所有线程共享的,所有字段和方法字节码,以及一些特殊方法,如构造函数,接口代码也在此定义,简单说,所有定义的方法的信息都保存在该区域,此区域属于共享区间;</p>
<p> 静态变量(static),常量(final),类信息(构造方法,接口定义),运行时的常量池存在方法区中,但是实例变量存在堆内存中,和方法区无关.</p>
<p>static ,final, Class , 常量池</p>
<h1 id="9-栈"><a href="#9-栈" class="headerlink" title="9.栈"></a>9.栈</h1><p>栈: 先进后出,后进先出</p>
<p>队列: 先进先出 (FIFO)</p>
<p>喝多了吐就是栈,吃多了拉就是队列</p>
<p>栈:栈内存,主管程序的运行,生命周期和线程同步;</p>
<p> 线程结束,栈内存也就释放了,对于栈来说,不存在垃圾回收问题</p>
<p> 一旦线程结束,栈就Over</p>
<p>栈:8大基本类型+ 对象引用+实例的方法</p>
<p><img src="C:\Users\chenn-a\Desktop\图片\栈.png" alt="栈"></p>
<p>栈 + 堆 +方法区:交互关系</p>
<p><img src="C:\Users\chenn-a\Desktop\图片\栈堆方法区交互.png" alt="栈堆方法区交互"></p>
<p>在内存中画出一个对象的实例化过程</p>
<h1 id="10-三种JVM"><a href="#10-三种JVM" class="headerlink" title="10.三种JVM"></a>10.三种JVM</h1><p><img src="C:\Users\chenn-a\Desktop\图片\三中JVm.png" alt="三中JVm"></p>
<h1 id="11-堆"><a href="#11-堆" class="headerlink" title="11.堆"></a>11.堆</h1><p>Heap,一个JVM只有一个堆内存,堆内存的大小是可以调节的.</p>
<p>类加载器读取了类文件后,一般会把什么东西放到堆中? 类, 方法 , 常量 , 变量 , ~,保存我们所有引用类型的真实对象;</p>
<p>堆内存中还要细分为三个区域:</p>
<p>新生区 (伊甸园区) Young/New</p>
<p>养老区 old</p>
<p>永久区 Perm jdk8之后叫做 “元空间”</p>
<blockquote>
<p>JDK 1.8以后永久区改成了“元空间”，原来作用在JVM中，直接放到了内存中</p>
</blockquote>
<p><img src="C:\Users\chenn-a\Desktop\图片\堆1.png" alt="堆1"></p>
<p><img src="C:\Users\chenn-a\Desktop\图片\堆2.png" alt="堆2"></p>
<p>GC垃圾回收, 主要在伊甸园区和养老区~</p>
<p>假设内存满了,OOM内存不够了! java.lang.OutOfMemoryError: java heap space</p>
<h2 id="1-新生区-（满了-轻GC）"><a href="#1-新生区-（满了-轻GC）" class="headerlink" title="1.新生区 （满了 轻GC）"></a>1.新生区 （满了 轻GC）</h2><ul>
<li><p>类 ： 诞生和成长的地方 ， 甚至死亡；</p>
</li>
<li><p>伊甸园， 所有的对象都是在伊甸园区new出来的</p>
</li>
<li><p>幸存区（0，1）</p>
</li>
<li><p>经研究99%的对象都是临时对象</p>
</li>
</ul>
<h2 id="2-老年区-（满了-重GC）"><a href="#2-老年区-（满了-重GC）" class="headerlink" title="2.老年区 （满了 重GC）"></a>2.老年区 （满了 重GC）</h2><p>永久区</p>
<p>这个区域常驻内存的. 用来存放jdk自身携带的Class对象.Interface元数据,存储的是java运行时的一些环境或类信息,这个区域不存在垃圾回收!关闭vm虚拟就会释放这个区域的内存~.</p>
<ol>
<li><p>jdk1.6之前 :永久代,常量池是在方法区;</p>
</li>
<li><p>jdk1.7 :永久代,但是慢慢退化了, 去永久代,常量池在堆中;</p>
</li>
<li><p>jdk1.8之后:无永久代, 常量池在元空间;</p>
</li>
<li><p>堆</p>
</li>
</ol>
<p><img src="C:\Users\chenn-a\Desktop\图片\堆永久区.png" alt="堆永久区"></p>
<ol start="5">
<li>元空间:逻辑上存在,物理上不存在</li>
</ol>
<h2 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h2><p>默认情况下: 分配的总内存 是电脑内存的1/4,而初始化的内存: 1/64</p>
<p>OOM:堆内存溢出</p>
<ul>
<li><p>尝试扩大堆内存看结果<br>-Xms1024m -Xmx1024m -xx:+PrintGCDetails</p>
</li>
<li><p>分析内存,看一下哪个地方出现了问题 (专业工具)</p>
</li>
</ul>
<p>在一个项目中,突然出现了OOM故障,那么该如何排除~研究为什么出错</p>
<ul>
<li><p>能够看到代码第几行出错:内存快照分析工具,MAT,Jprofiler</p>
</li>
<li><p>Dubug,一行行分析代码</p>
</li>
</ul>
<h2 id="MAT-Jprogiler作用"><a href="#MAT-Jprogiler作用" class="headerlink" title="MAT,Jprogiler作用:"></a>MAT,Jprogiler作用:</h2><h2 id="jprofiler使用"><a href="#jprofiler使用" class="headerlink" title="jprofiler使用"></a>jprofiler使用</h2><p>-Xms 设置初始化内存分配大小 1/64</p>
<p>-Xmx 设置最大分配内存,默认1/4</p>
<p>-XX:+HeapDumpOnOutOfMemoryError oomDump</p>
<h1 id="12-GC-垃圾回收"><a href="#12-GC-垃圾回收" class="headerlink" title="12.GC:垃圾回收"></a>12.GC:垃圾回收</h1><h2 id="GC-作用区域-堆-方法区"><a href="#GC-作用区域-堆-方法区" class="headerlink" title="GC:作用区域 堆+方法区"></a>GC:作用区域 堆+方法区</h2><p>JVM在进行GC时，并不是对这三个区域统一回收。大部分时候，回收都是新生代~</p>
<p>新生代<br>幸存区（form ， to）<br>老年区<br>GC两种：轻GC（普通GC），重GC（全局GC）</p>
<h2 id="GC题目"><a href="#GC题目" class="headerlink" title="GC题目"></a>GC题目</h2><p>JVM的内存模型和分区~详细到每个区放什么?<br>堆里面的分区有哪些? Eden,form,to,老年区,说说他们的特点?<br>GC的算法有哪些? 标记清除法 , 标记压缩 , 复制算法, 引用计数器, 怎么用的?<br>轻GC和重GC分别在什么时候发生?</p>
<h1 id="13-常用算法"><a href="#13-常用算法" class="headerlink" title="13.常用算法"></a>13.常用算法</h1><ol>
<li><p><strong>引用计数法</strong></p>
<p><img src="C:\Users\chenn-a\Desktop\图片\引用计数法.png" alt="引用计数法"></p>
</li>
<li><p><strong>复制算法</strong></p>
</li>
</ol>
<p><img src="C:\Users\chenn-a\Desktop\图片\复制算法.png" alt="复制算法"></p>
<p><img src="C:\Users\chenn-a\Desktop\图片\复制算法2.png" alt="复制算法2"></p>
<p>好处:没有内存的碎片<br>坏处:浪费了内存空间:多了一半空间永远是空 to.假设对象100%存活(极端情况)<br>复制算法最佳使用场景:对象存活度较低的时候:新生区;</p>
<ol start="3">
<li><p><strong>标记清除算法</strong></p>
<p><img src="C:\Users\chenn-a\Desktop\图片\标记清除法.png" alt="标记清除法"></p>
</li>
</ol>
<p>优点:不需要额外的空间<br>缺点:两次扫描,严重浪费时间,会产生内存碎片</p>
<ol start="5">
<li><strong>标记压缩(优化标记清除)</strong></li>
</ol>
<p><img src="C:\Users\chenn-a\Desktop\图片\标记清除压缩法.png" alt="标记清除压缩法"></p>
<p>三部曲:标记,清除.压缩<br><strong>如何选择四种算法:</strong><br>**内存效率:**复制算法&gt;标记清除算法&gt;标记压缩算法(时间复杂度)</p>
<p>**内存整齐度:**复制算法=标记压缩算法&gt;标记清除算法</p>
<p>**内存利用率:**标记压缩算法=标记清除算法&gt;复制算法</p>
<p>难道没有一个最优的算法吗?</p>
<p>答案:没有,没有最好的算法,只有最合适的算法—-&gt;GC:分带收集算法</p>
<p><strong>年轻代:</strong></p>
<p>存活率低<br>复制算法<br>老年代：</p>
<p>区域大：存活率<br>标记清除（内存碎片不是太多）+标记压缩混合实现</p>
<h1 id="14-JMM"><a href="#14-JMM" class="headerlink" title="14.JMM"></a>14.JMM</h1><p>1.什么是JMM？</p>
<p>JMM ：（java Memory Model 缩写）java内存模型</p>
<p>2.他是干什么的？</p>
<p><img src="C:\Users\chenn-a\Desktop\图片\JMM.png" alt="JMM"></p>
<p>解决共享对象可见性的问题：volilate</p>
<p>3.他该如何学习</p>
<p>JMM ：抽象的概念，理论</p>
<p> <img src="C:\Users\chenn-a\Desktop\图片\1.png" alt="1"></p>
<p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。<br>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。<br>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用<br>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。<br>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。<br>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。<br>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。<br>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。<br><img src="C:\Users\chenn-a\Desktop\图片\JMM1.png" alt="JMM1"></p>
<p>参考地址 周洋的面试题</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lookfordream_/category_7718088.html">https://blog.csdn.net/lookfordream_/category_7718088.html</a></p>
<h1 id="15-volilate"><a href="#15-volilate" class="headerlink" title="15 volilate"></a>15 volilate</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><strong>volatile</strong>关键字是为了保证线程安全，线程安全意味着一个方法或类实例可以被多个线程同时使用，而不会出现任何问题。它提供的功能主要有两点：</p>
<ul>
<li><p>保证可见性</p>
</li>
<li><p>禁止指令重排序</p>
</li>
<li><p><strong>不保证原子性</strong></p>
</li>
</ul>
<p>不使用synchronized解决原子性可以使用java.util.concurrent.automic下的原子类AtomicInteger实现</p>
<p>使用下面的CAS实现</p>
<h1 id="16-CAS底层原理"><a href="#16-CAS底层原理" class="headerlink" title="16 CAS底层原理"></a>16 CAS底层原理</h1><h2 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h2><p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p>
<p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p>
<p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p>
<h2 id="2、代码使用"><a href="#2、代码使用" class="headerlink" title="2、代码使用"></a>2、代码使用</h2><p>首先调用AtomicInteger创建了一个实例， 并初始化为5</p>
<p>// 创建一个原子类<br>AtomicInteger atomicInteger = new AtomicInteger(5);</p>
<p>然后调用CAS方法，企图更新成2019，这里有两个参数，一个是5，表示期望值，第二个就是我们要更新的值</p>
<p>atomicInteger.compareAndSet(5, 2019)</p>
<p>然后再次使用了一个方法，同样将值改成1024</p>
<p>atomicInteger.compareAndSet(5, 1024) </p>
<h2 id="3、CAS底层原理"><a href="#3、CAS底层原理" class="headerlink" title="3、CAS底层原理"></a>3、CAS底层原理</h2><p> 这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。<br>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p>
<p><strong>在本地方法栈去Native关键字调用c++的方法执行内存方法</strong></p>
<p>底层汇编<br>Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p>
<p>先想办法拿到变量value在内存中的地址<br>通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</p>
<h2 id="4、CAS-缺点"><a href="#4、CAS-缺点" class="headerlink" title="4、CAS 缺点"></a>4、CAS 缺点</h2><p>CAS不加锁，保证一次性，但是需要多次比较</p>
<p>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）<br>只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作<br>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</p>
<h2 id="5、-总结"><a href="#5、-总结" class="headerlink" title="5、 总结"></a>5、 总结</h2><p>CAS<br>CAS是compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止</p>
<p>CAS应用<br>CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做</p>
<h1 id="17、原子类AtomicInteger的ABA问题"><a href="#17、原子类AtomicInteger的ABA问题" class="headerlink" title="17、原子类AtomicInteger的ABA问题"></a>17、原子类AtomicInteger的ABA问题</h1><h2 id="1、连环套路"><a href="#1、连环套路" class="headerlink" title="1、连环套路"></a>1、连环套路</h2><p>从AtomicInteger引出下面的问题</p>
<p>CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题</p>
<p><strong>CAS导致ABA问题</strong><br>CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p>
<p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p>
<p><strong>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的</strong></p>
<p><strong>ABA问题</strong><br>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功，中间的这个过程，可能会被人修改过<br><strong>原子引用</strong></p>
<p>原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原子引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-11-22:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User z3 = <span class="keyword">new</span> User(<span class="string">&quot;z3&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        User l4 = <span class="keyword">new</span> User(<span class="string">&quot;l4&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在主物理内存的共享变量，为z3</span></span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="2、解决ABA问题"><a href="#2、解决ABA问题" class="headerlink" title="2、解决ABA问题"></a>2、解决ABA问题</h2><p>新增一种机制，也就是修改版本号，类似于时间戳的概念</p>
<p>如果T1修改的时候，版本号为2，落后于现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路</p>
<p><strong>AtomicStampedReference</strong><br>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ABA问题的解决，AtomicStampedReference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-12-15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的原子引用包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递两个值，一个是初始值，一个是初始版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的产生==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t3一秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否：&quot;</span> + result + <span class="string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\chenn-a\Desktop\图片\aba原型结果.png" alt="aba原型结果"></p>
<p>我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样</p>
<h1 id="18、Collection线程不安全的举例"><a href="#18、Collection线程不安全的举例" class="headerlink" title="18、Collection线程不安全的举例"></a>18、Collection线程不安全的举例</h1><p>参考地址 <a target="_blank" rel="noopener" href="https://blog.csdn.net/LookForDream_/article/details/105831364">https://blog.csdn.net/LookForDream_/article/details/105831364</a></p>
<p>ArrayList、HashSet、HashMap都是线程不安全的 HashTable是线程安全的 </p>
<h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>为什么ArrayList是线程不安全的？因为进行写操作的时候，方法上为了保证并发性，没有添加sychronized修饰，所以并发性写的时候，就会出现问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：Vector"><a href="#方案一：Vector" class="headerlink" title="方案一：Vector"></a>方案一：Vector</h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类。而采用Vector，线程安全的<br>关于Vector如何实现线程安全的，而方法上加了锁，即synchronized</p>
<p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，并导致并发性下降。</p>
<h3 id="方案二：Collections-sychronized"><a href="#方案二：Collections-sychronized" class="headerlink" title="方案二：Collections.sychronized()"></a>方案二：Collections.sychronized()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.sychronizedList(<span class="keyword">new</span> List());</span><br></pre></td></tr></table></figure>

<h3 id="方案三：采用JUC里面的方法"><a href="#方案三：采用JUC里面的方法" class="headerlink" title="方案三：采用JUC里面的方法"></a>方案三：采用JUC里面的方法</h3><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p>
<p>查看底层add方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="19、Java-的锁"><a href="#19、Java-的锁" class="headerlink" title="19、Java 的锁"></a>19、Java 的锁</h1><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p>
<h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><p>并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>公平锁：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后安装FIFO的规则从队列中取到自己</p>
<p>非公平锁： 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，对于synchronized而言，也是一种非公平锁.</p>
<h2 id="可重入锁-递归锁-ReentrantLock"><a href="#可重入锁-递归锁-ReentrantLock" class="headerlink" title="可重入锁(递归锁)ReentrantLock"></a>可重入锁(递归锁)ReentrantLock</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>可重入锁就是递归锁<br>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p>
<p>也就是说：线程可以进入任何一个它已经拥有的锁所同步的代码块</p>
<p>ReentrantLock / Synchronized 就是一个典型的可重入锁.<br>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁.<br> 也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可重入锁的最大作用就是避免死锁</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><strong>自旋锁</strong>：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<p>原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：循环比较获取直到成功为止，没有类似于wait的阻塞</p>
<p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p>
<h2 id="独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="独占锁（写锁） / 共享锁（读锁） / 互斥锁"></a>独占锁（写锁） / 共享锁（读锁） / 互斥锁</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁</p>
<p>共享锁：指该锁可以被多个线程锁持有</p>
<p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p>
<p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p>
<h3 id="为什么会有写锁和读锁"><a href="#为什么会有写锁和读锁" class="headerlink" title="为什么会有写锁和读锁"></a>为什么会有写锁和读锁</h3><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读</p>
<p>多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，<br>但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p>
<p>读-读：能共存<br>读-写：不能共存<br>写-写：不能共存</p>
<h1 id="20、CountDownLatch-CyclicBarrier-Semaphore"><a href="#20、CountDownLatch-CyclicBarrier-Semaphore" class="headerlink" title="20、CountDownLatch_CyclicBarrier_Semaphore"></a>20、CountDownLatch_CyclicBarrier_Semaphore</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p>
<p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moxi.interview.study.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-04-15-19:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 上完自习，离开教室&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 班长最后关门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行</p>
<p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CyclicBarrier循环屏障</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 轻狂书生FS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-04-16-14:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="Semaphore：信号量"><a href="#Semaphore：信号量" class="headerlink" title="Semaphore：信号量"></a>Semaphore：信号量</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>信号量主要用于两个目的：</p>
<ul>
<li>一个是用于共享资源的互斥使用</li>
<li>另一个用于并发线程数的控制</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我们模拟一个抢车位的场景，假设一共有6个车，3个停车位<br>那么我们首先需要定义信号量为3，也就是3个停车位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信号量Demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 轻狂书生FS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-16-15:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟6部车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 代表一辆车，已经占用了该车位</span></span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 抢占</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 抢到车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每个车停3秒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 离开车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="21、阻塞队列"><a href="#21、阻塞队列" class="headerlink" title="21、阻塞队列"></a>21、阻塞队列</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p>
<p><img src="C:\Users\chenn-a\Desktop\图片\阻塞队列.png" alt="阻塞队列">线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p>
<p>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞<br>当蛋糕店的柜子空的时候，无法从柜子里面获取蛋糕<br>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞<br>当蛋糕店的柜子满的时候，无法继续向柜子里面添加蛋糕了<br>也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素<br>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</p>
<h3 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h3><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞<br>在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</p>
<h3 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h3><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了<br>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h3 id="BlockingQueue阻塞队列是属于一个接口，底下有七个实现类"><a href="#BlockingQueue阻塞队列是属于一个接口，底下有七个实现类" class="headerlink" title="BlockingQueue阻塞队列是属于一个接口，底下有七个实现类"></a>BlockingQueue阻塞队列是属于一个接口，底下有七个实现类</h3><p>ArrayBlockQueue：由数组结构组成的有界阻塞队列<br>LinkedBlockingQueue：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<br>有界，但是界限非常大，相当于无界，可以当成无界<br>PriorityBlockQueue：支持优先级排序的无界阻塞队列<br>DelayQueue：使用优先级队列实现的延迟无界阻塞队列<br>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列<br>生产一个，消费一个，不存储元素，不消费不生产<br>LinkedTransferQueue：由链表结构组成的无界阻塞队列<br>LinkedBlockingDeque：由链表结构组成的双向阻塞队列<br>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p>
<h3 id="BlockingQueue核心方法"><a href="#BlockingQueue核心方法" class="headerlink" title="BlockingQueue核心方法"></a>BlockingQueue核心方法</h3><p> <img src="C:\Users\chenn-a\Desktop\图片\阻塞队列方法.png" alt="阻塞队列方法"></p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue，每一个put操作必须等待一个take操作，否者不能继续添加元素</p>
<h3 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h3><h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><p>一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</p>
<p>关于多线程的操作，我们需要记住下面几句</p>
<ul>
<li>线程 操作 资源类</li>
<li>判断 干活 通知</li>
<li>防止虚假唤醒机制<br>我们下面实现一个简单的生产者消费者模式，首先有资源类ShareData</li>
</ul>
<h1 id="22、synchronized和lock的区别"><a href="#22、synchronized和lock的区别" class="headerlink" title="22、synchronized和lock的区别"></a>22、synchronized和lock的区别</h1><p>synchronize和Lock有什么区别？用新的Lock有什么好处？请举例说明</p>
<h2 id="1、原始构成"><a href="#1、原始构成" class="headerlink" title="1、原始构成"></a>1、原始构成</h2><ul>
<li><p>synchronized是关键字属于JVM的层面</p>
<p>使用monitorenter</p>
<p> monitorexit</p>
</li>
<li><p>Lock是具体类（java.until.concurrent.Locks.Lock）是api层面的锁</p>
</li>
</ul>
<h2 id="2、使用方法"><a href="#2、使用方法" class="headerlink" title="2、使用方法"></a>2、使用方法</h2><ul>
<li>synchronized 不需要用户去手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用</li>
<li>ReentrantLock 则需要用户去手动释放锁，若没有主动释放锁，就有可能导致死锁现象</li>
</ul>
<h2 id="3、等待是否可中断"><a href="#3、等待是否可中断" class="headerlink" title="3、等待是否可中断"></a>3、等待是否可中断</h2><ul>
<li>synchronized不可中断，除非抛出异常或者正常运行结束</li>
<li>ReentrantLock可以中断 1、设置超时方法 tryLock（Long timeout, TimeUnit unit) 2、LockInterUptibly ()放到代码块中，调用interrrupt 方法可中断</li>
</ul>
<h2 id="4、加锁是否公平锁"><a href="#4、加锁是否公平锁" class="headerlink" title="4、加锁是否公平锁"></a>4、加锁是否公平锁</h2><ul>
<li>synchronzed 非公平锁</li>
<li>ReentrantLock 两者都可以，默认公平锁，构造参数传参 true false</li>
</ul>
<h2 id="5、锁绑定多个条件Condition"><a href="#5、锁绑定多个条件Condition" class="headerlink" title="5、锁绑定多个条件Condition"></a>5、锁绑定多个条件Condition</h2><ul>
<li>synchronized 没有</li>
<li>ReentrantLock 用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程</li>
</ul>
<h1 id="23、HashMap底层实现原理"><a href="#23、HashMap底层实现原理" class="headerlink" title="23、HashMap底层实现原理"></a>23、HashMap底层实现原理</h1><p>底层是基于数组+链表+红黑色实现</p>
<p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<h4 id="HashMap-是基于-hashing-的原理"><a href="#HashMap-是基于-hashing-的原理" class="headerlink" title="HashMap 是基于 hashing 的原理"></a>HashMap 是基于 hashing 的原理</h4><p>我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。</p>
<p>这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node[] table = <span class="keyword">new</span> Node[<span class="number">16</span>]; <span class="comment">// 散列桶初始化，table 第一次put的时候创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    hash; <span class="comment">//hash值</span></span><br><span class="line">    key; <span class="comment">//键</span></span><br><span class="line">    value; <span class="comment">//值</span></span><br><span class="line">    node next; <span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以下是具体的-put-过程（JDK1-8）"><a href="#以下是具体的-put-过程（JDK1-8）" class="headerlink" title="以下是具体的 put 过程（JDK1.8）"></a>以下是具体的 put 过程（JDK1.8）</h4><p>1.计算关于key的hashcode值（与Key.hashCode的高16位做异或运算）</p>
<p>2.如果散列表为空时，调用resize()初始化散列表</p>
<p>3.如果没有发生碰撞，直接添加元素到散列表中去</p>
<p>4.如果发生了碰撞(hashCode值相同)，进行三种判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4.1:若key地址相同或者equals后内容相同，则替换旧值</span><br><span class="line"></span><br><span class="line">4.2:如果是红黑树结构，就调用树的插入方法</span><br><span class="line"></span><br><span class="line">4.3：链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，插入之后判断链表个数是否到达变成红黑树的阙值8；也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖。链表长度低于6，就把红黑树转回链表 使用尾插法</span><br></pre></td></tr></table></figure>

<p>5.如果桶满了大于阀值（容量16*加载因子0.75），则resize进行扩容（扩容2倍后重排）</p>
<h4 id="以下是具体-get-过程"><a href="#以下是具体-get-过程" class="headerlink" title="以下是具体 get 过程"></a>以下是具体 get 过程</h4><p>对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。</p>
<p><a target="_blank" rel="noopener" href="http://www.codeinn.net/misctech/1718.html">http://www.codeinn.net/misctech/1718.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zengcongcong/p/11295349.html">https://www.cnblogs.com/zengcongcong/p/11295349.html</a></p>
<h1 id="24、ConcurrentHashMap"><a href="#24、ConcurrentHashMap" class="headerlink" title="24、ConcurrentHashMap"></a>24、ConcurrentHashMap</h1><p>JDK 1.7 是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p>
<p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<h2 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h2><ol>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>最后会解除在 1 中所获取当前 Segment 的锁。</li>
</ol>
<h2 id="get-逻辑比较简单："><a href="#get-逻辑比较简单：" class="headerlink" title="get 逻辑比较简单："></a>get 逻辑比较简单：</h2><p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p>
<p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p>
<p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p>
<h2 id="JDK1-8-后的更改"><a href="#JDK1-8-后的更改" class="headerlink" title="JDK1.8 后的更改"></a>JDK1.8 后的更改</h2><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。</p>
<blockquote>
<p>那就是查询遍历链表效率太低。</p>
</blockquote>
<p>因此 1.8 做了一些数据结构上的调整。 </p>
<p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
<h2 id="Put-1"><a href="#Put-1" class="headerlink" title="Put"></a>Put</h2><ul>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ul>
<h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><ul>
<li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li>
<li>如果是红黑树那就按照树的方式获取值。</li>
<li>就不满足那就按照链表的方式遍历获取值。</li>
</ul>
<blockquote>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p>
</blockquote>
<h1 id="25、ThreadLocal"><a href="#25、ThreadLocal" class="headerlink" title="25、ThreadLocal"></a>25、ThreadLocal</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fsmly/p/11020641.html">https://www.cnblogs.com/fsmly/p/11020641.html</a></p>
<p><strong>线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每个线程创建一个单独的变量副本，每个线程都可以改变自己的变量副本而不影响其它线程所对应的副本。</strong></p>
<h2 id="1、ThreadLocal简介"><a href="#1、ThreadLocal简介" class="headerlink" title="1、ThreadLocal简介"></a>1、ThreadLocal简介</h2><p>　　多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。</p>
<p>　　ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一乐ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题，如下图所示</p>
<p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png" alt="img"></p>
<h2 id="2、ThreadLocal简单使用"><a href="#2、ThreadLocal简单使用" class="headerlink" title="2、ThreadLocal简单使用"></a>2、ThreadLocal简单使用</h2><p>　下面的例子中，开启两个线程，在每个线程内部设置了本地变量的值，然后调用print方法打印当前本地变量的值。如果在打印之后调用本地变量的remove方法会删除本地内存中的变量，代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + localVar.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        localVar.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">                localVar.set(<span class="string">&quot;localVar1&quot;</span>);</span><br><span class="line">                <span class="comment">//调用打印方法</span></span><br><span class="line">                print(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">                localVar.set(<span class="string">&quot;localVar2&quot;</span>);</span><br><span class="line">                <span class="comment">//调用打印方法</span></span><br><span class="line">                print(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 下面是运行后的结果：</p>
<p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613224945385-1072836449.png" alt="img"></p>
<h2 id="3、ThreadLocal的实现原理"><a href="#3、ThreadLocal的实现原理" class="headerlink" title="3、ThreadLocal的实现原理"></a>3、ThreadLocal的实现原理</h2><p>　　下面是ThreadLocal的类图结构，从图中可知：Thread类中有两个变量threadLocals和inheritableThreadLocals，二者都是ThreadLocal内部类ThreadLocalMap类型的变量，我们通过查看内部内ThreadLocalMap可以发现实际上它类似于一个HashMap。在默认情况下，每个线程中的这两个变量都为null<img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614002358591-1764103391.png" alt="img"><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614002426565-1963789099.png" alt="img">，只有当线程第一次调用ThreadLocal的set或者get方法的时候才会创建他们（后面我们会查看这两个方法的源码）。除此之外，和我所想的不同的是，每个线程的本地变量不是存放在ThreadLocal实例中，而是放在调用线程的ThreadLocals变量里面（前面也说过，该变量是Thread类的变量）。也就是说，ThreadLocal类型的本地变量是存放在具体的线程空间上，其本身相当于一个装载本地变量的工具壳，通过set方法将value添加到调用线程的threadLocals中，当调用线程调用get方法时候能够从它的threadLocals中取出变量。如果调用线程一直不终止，那么这个本地变量将会一直存放在他的threadLocals中，所以不使用本地变量的时候需要调用remove方法将threadLocals中删除不用的本地变量。下面我们通过查看ThreadLocal的set、get以及remove方法来查看ThreadLocal具体实怎样工作的</p>
<p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614000329689-872917045.png" alt="img"></p>
<p>1、set方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)获取当前线程（调用者线程）</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2)以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//(3)如果map不为null，就直接添加本地变量，key为当前定义的ThreadLocal变量的this引用，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//(4)如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，(2)处调用getMap方法获得当前线程对应的threadLocals(参照上面的图示和文字说明)，该方法代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals; <span class="comment">//获取线程自己的变量threadLocals，并绑定到当前调用线程的成员变量threadLocals上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用getMap方法返回值不为null，就直接将value值设置到threadLocals中（key为当前线程引用，值为本地变量）；如果getMap方法返回null说明是第一次调用set方法（前面说到过，threadLocals默认值为null，只有调用set方法的时候才会创建map），这个时候就需要调用createMap方法创建threadLocals，该方法如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line"><span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>　createMap方法不仅创建了threadLocals，同时也将要添加的本地变量值添加到了threadLocals中。</p>
<p>　2、get方法源码</p>
<p>在get方法的实现中，首先获取当前调用者线程，如果当前线程的threadLocals不为null，就直接返回当前线程绑定的本地变量值，否则执行setInitialValue方法初始化threadLocals变量。在setInitialValue方法中，类似于set方法的实现，都是判断当前线程的threadLocals变量是否为null，是则添加本地变量（这个时候由于是初始化，所以添加的值为null），否则创建threadLocals变量，同样添加的值为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//(2)获取当前线程的threadLocals变量</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//(3)如果threadLocals变量不为null，就可以在map中查找到本地变量的值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(4)执行到此处，threadLocals为null，调用该更改初始化当前线程的threadLocals变量</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//protected T initialValue() &#123;return null;&#125;</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//以当前线程作为key值，去查找对应的线程变量，找到对应的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果map不为null，就直接添加本地变量，key为当前线程，值为添加的本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">//如果map为null，说明首次添加，需要首先创建出对应的map</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　3、remove方法的实现</p>
<p>　　remove方法判断该当前线程对应的threadLocals变量是否为null，不为null就直接删除当前线程中指定的threadLocals变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程绑定的threadLocals</span></span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="comment">//如果map不为null，就移除当前线程中指定ThreadLocal实例的本地变量</span></span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>4、如下图所示：每个线程内部有一个名为threadLocals的成员变量，该变量的类型为ThreadLocal.ThreadLocalMap类型（类似于一个HashMap），其中的key为当前定义的ThreadLocal变量的this引用，value为我们使用set方法设置的值。每个线程的本地变量存放在自己的本地内存变量threadLocals中，如果当前线程一直不消亡，那么这些本地变量就会一直存在（所以可能会导致内存溢出），因此使用完毕需要将其remove掉。</p>
<p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614011044060-2111473950.png" alt="img"></p>
<blockquote>
<p>同一个ThreadLocal变量在父线程中被设置值后，在子线程中是获取不到的。（threadLocals中为当前调用线程对应的本地变量，所以二者自然是不能共享的）</p>
</blockquote>
<h2 id="4、从ThreadLocalMap看ThreadLocal使用不当的内存泄漏问题"><a href="#4、从ThreadLocalMap看ThreadLocal使用不当的内存泄漏问题" class="headerlink" title="4、从ThreadLocalMap看ThreadLocal使用不当的内存泄漏问题"></a>4、从ThreadLocalMap看ThreadLocal使用不当的内存泄漏问题</h2><h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>　　首先我们先看看ThreadLocalMap的类图，在前面的介绍中，我们知道ThreadLocal只是一个工具类，他为用户提供get、set、remove接口操作实际存放本地变量的threadLocals（调用线程的成员变量），也知道threadLocals是一个ThreadLocalMap类型的变量，下面我们来看看ThreadLocalMap这个类。在此之前，我们回忆一下Java中的四种引用类型，相关GC只是参考前面系列的文章(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fsmly/category/1387642.html">JVM相关</a>)</p>
<p>①强引用：Java中默认的引用类型，一个对象如果具有强引用那么只要这种引用还存在就不会被GC。</p>
<p>②软引用：简言之，如果一个对象具有弱引用，在JVM发生OOM之前（即内存充足够使用），是不会GC这个对象的；只有到JVM内存不足的时候才会GC掉这个对象。软引用和一个引用队列联合使用，如果软引用所引用的对象被回收之后，该引用就会加入到与之关联的引用队列中</p>
<p>③弱引用（这里讨论ThreadLocalMap中的Entry类的重点）：如果一个对象只具有弱引用，那么这个对象就会被垃圾回收器GC掉(被弱引用所引用的对象只能生存到下一次GC之前，当发生GC时候，无论当前内存是否足够，弱引用所引用的对象都会被回收掉)。弱引用也是和一个引用队列联合使用，如果弱引用的对象被垃圾回收期回收掉，JVM会将这个引用加入到与之关联的引用队列中。若引用的对象可以通过弱引用的get方法得到，当引用的对象呗回收掉之后，再调用get方法就会返回null</p>
<p>④虚引用：虚引用是所有引用中最弱的一种引用，其存在就是为了将关联虚引用的对象在被GC掉之后收到一个通知。（不能通过get方法获得其指向的对象）</p>
<p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614105112553-1657649661.png" alt="img"></p>
<h3 id="2、分析ThreadLocalMap内部实现"><a href="#2、分析ThreadLocalMap内部实现" class="headerlink" title="2、分析ThreadLocalMap内部实现"></a>2、分析ThreadLocalMap内部实现</h3><p>　　上面我们知道ThreadLocalMap内部实际上是一个Entry数组<img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190614112107515-173627228.png" alt="img">，我们先看看Entry的这个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是继承自WeakReference的一个类，该类中实际存放的key是</span></span><br><span class="line"><span class="comment"> * 指向ThreadLocal的弱引用和与之对应的value值(该value值</span></span><br><span class="line"><span class="comment"> * 就是通过ThreadLocal的set方法传递过来的值)</span></span><br><span class="line"><span class="comment"> * 由于是弱引用，当get方法返回null的时候意味着坑能引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** value就是和ThreadLocal绑定的 */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：ThreadLocal的引用，被传递给WeakReference的构造方法</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//WeakReference构造方法(public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent); <span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reference构造方法</span></span><br><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);<span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>　　在上面的代码中，我们可以看出，当前ThreadLocal的引用k被传递给WeakReference的构造函数，所以ThreadLocalMap中的key为ThreadLocal的弱引用。当一个线程调用ThreadLocal的set方法设置变量的时候，当前线程的ThreadLocalMap就会存放一个记录，这个记录的key值为ThreadLocal的弱引用，value就是通过set设置的值。如果当前线程一直存在且没有调用该ThreadLocal的remove方法，如果这个时候别的地方还有对ThreadLocal的引用，那么当前线程中的ThreadLocalMap中会存在对ThreadLocal变量的引用和value对象的引用，是不会释放的，就会造成内存泄漏。</p>
<p>　　考虑这个ThreadLocal变量没有其他强依赖，如果当前线程还存在，由于线程的ThreadLocalMap里面的key是弱引用，所以当前线程的ThreadLocalMap里面的ThreadLocal变量的弱引用在gc的时候就被回收，但是对应的value还是存在的这就可能造成内存泄漏(因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)。</p>
<p>　　<strong>总结：THreadLocalMap中的Entry的key使用的是ThreadLocal对象的弱引用，在没有其他地方对ThreadLoca依赖，ThreadLocalMap中的ThreadLocal对象就会被回收掉，但是对应的不会被回收，这个时候Map中就可能存在key为null但是value不为null的项，这需要实际的时候使用完毕及时调用remove方法避免内存泄漏。</strong></p>
<h1 id="26、线程池"><a href="#26、线程池" class="headerlink" title="26、线程池"></a>26、线程池</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现Callable接口</p>
<ul>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>实例化Thread类</li>
<li>使用线程池获取</li>
</ul>
<h2 id="2、Callable接口"><a href="#2、Callable接口" class="headerlink" title="2、Callable接口"></a>2、Callable接口</h2><p>Callable接口，是一种让线程执行完成后，能够返回结果的<br>在说到Callable接口的时候，我们不得不提到Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，实现Runnable接口的时候，需要重写run方法，也就是线程在启动的时候，会自动调用的方法</p>
<p>同理，我们实现Callable接口，也需要实现call方法，但是这个时候我们还需要有返回值，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callable有返回值</span></span><br><span class="line"><span class="comment"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;come in Callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p>
<p>这里需要用到的是<strong>FutureTask</strong>类，他实现了Runnable接口，并且还需要传递一个实现Callable接口的类作为构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span></span><br><span class="line"><span class="comment">// 这里通过了FutureTask接触了Callable接口</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在用Thread进行实例化，传入实现Runnabnle接口的FutureTask的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后通过 futureTask.get() 获取到返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出FutureTask的返回值</span></span><br><span class="line">System.out.println(<span class="string">&quot;result FutureTask &quot;</span> + futureTask.get());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就相当于原来我们的方式是main方法一条龙之心，后面在引入Callable后，对于执行比较久的线程，可以单独新开一个线程进行执行，最后在进行汇总输出</p>
<p>最后需要注意的是 要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会导致阻塞，直到计算完成</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbW94aTE1OTc1My9MZWFybmluZ05vdGVzL3Jhdy9tYXN0ZXIvJUU2JUEwJUExJUU2JThCJTlCJUU5JTlEJUEyJUU4JUFGJTk1L0pVQy8xMF8lRTclQkElQkYlRTclQTglOEIlRTYlQjElQTAvaW1hZ2VzL2ltYWdlLTIwMjAwMzE3MTUyNTQxMjg0LnBuZw?x-oss-process=image/format,png" alt="img"><br>也就是说 futureTask.get() 需要放在最后执行，这样不会导致主线程阻塞</p>
<p>也可以使用下面算法，使用类似于自旋锁的方式来进行判断是否运行完毕</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断futureTask是否计算完成</span></span><br><span class="line"><span class="keyword">while</span>(!futureTask.isDone()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h2><p>多个线程执行 一个FutureTask的时候，只会计算一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启两个线程计算futureTask</span></span><br><span class="line"><span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要定义两个futureTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启两个线程计算futureTask</span></span><br><span class="line"><span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(futureTask2, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、ThreadPoolExecutor"><a href="#4、ThreadPoolExecutor" class="headerlink" title="4、ThreadPoolExecutor"></a>4、ThreadPoolExecutor</h2><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：线程复用、控制最大并发数、管理线程</p>
<p>线程池中的任务是放入到阻塞队列中的</p>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>多核处理的好处是：省略的上下文的切换开销</p>
<p>原来我们实例化对象的时候，是使用 new关键字进行创建，到了Spring后，我们学了IOC依赖注入，发现Spring帮我们将对象已经加载到了Spring容器中，只需要通过@Autowrite注解，就能够自动注入，从而使用</p>
<p>因此使用多线程有下列的好处</p>
<p>1、降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗<br>2、提高响应速度。当任务到达时，任务可以不需要等到线程创建就立即执行<br>3、提高线程的可管理性。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
<h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor这几个类。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbW94aTE1OTc1My9MZWFybmluZ05vdGVzL3Jhdy9tYXN0ZXIvJUU2JUEwJUExJUU2JThCJTlCJUU5JTlEJUEyJUU4JUFGJTk1L0pVQy8xMF8lRTclQkElQkYlRTclQTglOEIlRTYlQjElQTAvaW1hZ2VzL2ltYWdlLTIwMjAwMzE3MTc1MjQxMDA3LnBuZw?x-oss-process=image/format,png" alt="img"></p>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>1、Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池<br>执行长期的任务，性能好很多<br>创建一个定长线程池，可控制线程数最大并发数，超出的线程会在队列中等待<br>2、Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池<br>一个任务一个任务执行的场景<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</p>
<p>3、Executors.newCacheThreadPool(); 创建一个可扩容的线程池<br>执行很多短期异步的小程序或者负载教轻的服务器<br>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程<br>具体使用，首先我们需要使用Executors工具类，进行创建线程池，这里创建了一个拥有5个线程的线程池</p>
<p>具体使用，首先我们需要使用Executors工具类，进行创建线程池，这里创建了一个拥有5个线程的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>); </span><br><span class="line"><span class="comment">// 创建一个只有一个线程的线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newSingleThreadExecutor(); </span><br><span class="line"><span class="comment">// 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span></span><br><span class="line">ExecutorService threadPool = Executors.newCacheThreadPool(); </span><br></pre></td></tr></table></figure>

<p>然后我们执行下面的的应用场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">##模拟<span class="number">10</span>个用户来办理业务，每个用户就是一个来自外部请求线程</span><br><span class="line">我们需要使用 threadPool.execute执行业务，execute需要传入一个实现了Runnable接口的线程</span><br><span class="line">    </span><br><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">	System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户办理业务&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">然后我们使用完毕后关闭线程池</span><br><span class="line"> threadPool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第四种获取 / 使用 Java多线程的方式，通过线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 轻狂书生FS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-04-17-15:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Array  Arrays(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Collection Collections(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Executor Executors(辅助工具类)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">最后结果：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 给用户:<span class="number">0</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>	 给用户:<span class="number">4</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 给用户:<span class="number">5</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>	 给用户:<span class="number">3</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>	 给用户:<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>	 给用户:<span class="number">2</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>	 给用户:<span class="number">9</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>	 给用户:<span class="number">8</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 给用户:<span class="number">7</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>	 给用户:<span class="number">6</span> 办理业务</span><br><span class="line">我们能够看到，一共有<span class="number">5</span>个线程，在给<span class="number">10</span>个用户办理业务</span><br></pre></td></tr></table></figure>

<h3 id="5、底层实现"><a href="#5、底层实现" class="headerlink" title="5、底层实现"></a>5、底层实现</h3><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了ThreadPoolExecutor</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbW94aTE1OTc1My9MZWFybmluZ05vdGVzL3Jhdy9tYXN0ZXIvJUU2JUEwJUExJUU2JThCJTlCJUU5JTlEJUEyJUU4JUFGJTk1L0pVQy8xMF8lRTclQkElQkYlRTclQTglOEIlRTYlQjElQTAvaW1hZ2VzL2ltYWdlLTIwMjAwMzE3MTgyMDA0MjkzLnBuZw?x-oss-process=image/format,png" alt="img"><br>我们可以看到线程池的内部，还使用到了LinkedBlockingQueue 链表阻塞队列<br>同时在查看Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue阻塞队列<br>最后查看一下，完整的三个创建线程的方法</p>
<p>我们可以看到线程池的内部，还使用到了LinkedBlockingQueue 链表阻塞队列<br>同时在查看Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue阻塞队列<br>最后查看一下，完整的三个创建线程的方法<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbW94aTE1OTc1My9MZWFybmluZ05vdGVzL3Jhdy9tYXN0ZXIvJUU2JUEwJUExJUU2JThCJTlCJUU5JTlEJUEyJUU4JUFGJTk1L0pVQy8xMF8lRTclQkElQkYlRTclQTglOEIlRTYlQjElQTAvaW1hZ2VzL2ltYWdlLTIwMjAwMzE3MTgzMjAyOTkyLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<h3 id="线程池的重要参数"><a href="#线程池的重要参数" class="headerlink" title="线程池的重要参数"></a>线程池的重要参数</h3><p>线程池在创建的时候，一共有7大参数</p>
<p><strong>corePoolSize</strong>：核心线程数，线程池中的常驻核心线程数<br>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程<br>当线程池中的线程数目达到corePoolSize后，就会把到达的队列放到缓存队列中<br><strong>maximumPoolSize</strong>：线程池能够容纳同时执行的最大线程数，此值必须大于等于1相当有扩容后的线程数，这个线程池能容纳的最多线程数<br><strong>keepAliveTime</strong>：多余的空闲线程存活时间<br>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止<br>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用<br><strong>unit</strong>：keepAliveTime的单位<br><strong>workQueue</strong>：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）<br>                        LinkedBlockingQueue：链表阻塞队列<br>                        SynchronousBlockingQueue：同步阻塞队列<br><strong>threadFactory</strong>：表示生成线程池中工作线程的线程工厂，用于创建线程池 一般用默认即可<br><strong>handler</strong>：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</p>
<h3 id="当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略"><a href="#当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略" class="headerlink" title="当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略"></a>当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略</h3><p><img src="https://img-blog.csdnimg.cn/2020051217395386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvb2tGb3JEcmVhbV8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>以下所有拒绝策略都实现了RejectedExecutionHandler接口</p>
<p>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行<br>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案<br>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者<br>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</p>
<h3 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h3><p><strong>线程池运行架构图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200512174016258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvb2tGb3JEcmVhbV8=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>文字说明</p>
<p>1、在创建了线程池后，等待提交过来的任务请求</p>
<p>2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p>
<p>​     如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务<br>​     如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列<br>​     如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程like运行这个任务；<br>​     如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行<br>3、当一个线程完成任务时，它会从队列中取下一个任务来执行</p>
<p>4、当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：</p>
<p>​         如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉<br>​         所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小<br>以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p>
<p>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理<br>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待<br>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题<br>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略<br>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</p>
<h3 id="为什么不用默认创建的线程池？"><a href="#为什么不用默认创建的线程池？" class="headerlink" title="为什么不用默认创建的线程池？"></a>为什么不用默认创建的线程池？</h3><p>线程池创建的方法有：固定数的，单一的，可变的，那么在实际开发中，应该使用哪个？</p>
<p>我们一个都不用，在生产环境中是使用自己自定义的</p>
<p>为什么不用Executors中JDK提供的？</p>
<p>根据阿里巴巴手册：并发控制这章</p>
<p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程<br>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题<br>线程池不允许使用Executors去创建，而是通过ThreadToolExecutors的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<br>Executors返回的线程池对象弊端如下：<br>FixedThreadPool和SingleThreadPool：<br>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM<br>CacheThreadPool和ScheduledThreadPool<br>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</p>
<h3 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h3><p><strong>采用默认拒绝策略</strong><br>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己手动创建线程池，然后指定阻塞队列的大小</p>
<p>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写线程池</span></span><br><span class="line">       <span class="keyword">final</span> Integer corePoolSize = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">final</span> Integer maximumPoolSize = <span class="number">5</span>;</span><br><span class="line">       <span class="keyword">final</span> Long keepAliveTime = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span></span><br><span class="line">       ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               corePoolSize,</span><br><span class="line">               maximumPoolSize,</span><br><span class="line">               keepAliveTime,</span><br><span class="line">               TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">               Executors.defaultThreadFactory(),</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后使用for循环，模拟10个用户来进行请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>但是在用户执行到第九个的时候，触发了异常，程序中断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 给用户:<span class="number">0</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>	 给用户:<span class="number">6</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>	 给用户:<span class="number">5</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>	 给用户:<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>	 给用户:<span class="number">4</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>	 给用户:<span class="number">7</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>	 给用户:<span class="number">2</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>	 给用户:<span class="number">3</span> 办理业务</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task com.moxi.interview.study.thread.MyThreadPoolDemo$$Lambda$<span class="number">1</span>/<span class="number">1747585824</span>@4dd8dc3 rejected from java.util.concurrent.ThreadPoolExecutor@6d03e736[Running, pool size = <span class="number">5</span>, active threads = <span class="number">3</span>, queued tasks = <span class="number">0</span>, completed tasks = <span class="number">5</span>]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2047</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">823</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1369</span>)</span><br><span class="line">	at com.moxi.interview.study.thread.MyThreadPoolDemo.main(MyThreadPoolDemo.java:<span class="number">34</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p>
<p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 = 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p>
<p><strong>1、拒绝策略是默认的AbortPolicy，也就是抛异常的 直接抛出异常</strong></p>
<p><strong>2、当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</strong></p>
<p><strong>3、采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</strong></p>
<p><strong>4、采用DiscardOldestPolicy拒绝策略,这个策略和刚刚差不多，会把最久的队列中的任务替换掉</strong></p>
<h3 id="线程池的合理参数"><a href="#线程池的合理参数" class="headerlink" title="线程池的合理参数"></a>线程池的合理参数</h3><p>生产环境中如何配置 corePoolSize 和 maximumPoolSize</p>
<p>这个是根据具体业务来配置的，分为CPU密集型和IO密集型</p>
<p>CPU密集型<br>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行<br>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p>
<p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p>
<p>CPU密集型任务配置尽可能少的线程数量：</p>
<p>一般公式：CPU核数 + 1个线程数</p>
<p>IO密集型<br>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p>
<p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p>
<p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p>
<p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p>
<p>参考公式：CPU核数 / (1 - 阻塞系数) 阻塞系数在0.8 ~ 0.9左右</p>
<p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p>
<h1 id="27、Hystrix"><a href="#27、Hystrix" class="headerlink" title="27、Hystrix"></a>27、Hystrix</h1><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，已提高分布式系统的弹性。</p>
<p>“ 断路器 ” 本身是一种开关装置，当某个服务单元发送故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<h2 id="Hystrix重要概念："><a href="#Hystrix重要概念：" class="headerlink" title="Hystrix重要概念："></a>Hystrix重要概念：</h2><p>1.服务降级：</p>
<p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback<br>哪些情况会发出降级？</p>
<p>程序运行异常<br>超时<br>服务熔断触发服务降级<br>线程池 / 信号量打满也会导致服务降级<br>2.服务熔断</p>
<p>类似保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p>
<p>3.服务限流</p>
<p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p>
<h2 id="配置项目："><a href="#配置项目：" class="headerlink" title="配置项目："></a>配置项目：</h2><p>需要在启动类配置的注解为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line">业务代码为：</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallBackMethod&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置的文件为application.yml：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line"> hystrix:</span><br><span class="line">   enabled: true</span><br></pre></td></tr></table></figure>

<p>一般都是在消费端配置断路器，因为不用来回传值。</p>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p><img src="C:\Users\chenn-a\AppData\Roaming\Typora\typora-user-images\image-20210517105350856.png" alt="image-20210517105350856"></p>
<p><img src="C:\Users\chenn-a\AppData\Roaming\Typora\typora-user-images\image-20210517110144433.png" alt="image-20210517110144433"></p>
<h1 id="28、spring循环依赖"><a href="#28、spring循环依赖" class="headerlink" title="28、spring循环依赖"></a>28、spring循环依赖</h1><p><img src="C:\Users\chenn-a\AppData\Roaming\Typora\typora-user-images\image-20210519090059980.png" alt="image-20210519090059980"></p>
<p><img src="C:\Users\chenn-a\AppData\Roaming\Typora\typora-user-images\image-20210519090304922.png" alt="image-20210519090304922"></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年10月16日 16:06</p>
        <p>原始链接： <a class="post-url" href="/2020/06/14/JVM/" title="JVM">https://zhanglc1998.github.io/2020/06/14/JVM/</a></p>
        <footer>
            <a href="https://zhanglc1998.github.io">
                <img src="/images/logo.png" alt="ZhangLichao">
                ZhangLichao
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://zhanglc1998.github.io/2020/06/14/JVM/&title=《JVM》 — ZhangLichao&pic=https://zhanglc1998.github.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://zhanglc1998.github.io/2020/06/14/JVM/&title=《JVM》 — ZhangLichao&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://zhanglc1998.github.io/2020/06/14/JVM/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM》 — ZhangLichao&url=https://zhanglc1998.github.io/2020/06/14/JVM/&via=https://zhanglc1998.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://zhanglc1998.github.io/2020/06/14/JVM/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://zhanglc1998.github.io/2020/06/14/JVM/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JVM%E6%8E%A2%E7%A9%B6"><span class="post-toc-text">JVM探究</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-jvm%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="post-toc-text">1.jvm的位置</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-jvm%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="post-toc-text">2.jvm的体系结构</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="post-toc-text">3.类加载器</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="post-toc-text">4.双亲委派机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="post-toc-text">1.1 什么是双亲委派机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="post-toc-text">1.2 类加载器的类别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#BootstrapClassLoader%EF%BC%88%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="post-toc-text">BootstrapClassLoader（启动类加载器）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ExtClassLoader-%EF%BC%88%E6%A0%87%E5%87%86%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="post-toc-text">ExtClassLoader （标准扩展类加载器）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AppClassLoader%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="post-toc-text">AppClassLoader（系统类加载器）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CustomClassLoader%EF%BC%88%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="post-toc-text">CustomClassLoader（用户自定义类加载器）</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="post-toc-text">1.3 源码分析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-4-%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="post-toc-text">1.4 委派机制的流程图</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-5-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="post-toc-text">1.5 双亲委派机制的作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="post-toc-text">5.沙箱安全机制</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-Native"><span class="post-toc-text">6.Native*</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-pc%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-text">7.pc寄存器</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="post-toc-text">8.方法区</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#9-%E6%A0%88"><span class="post-toc-text">9.栈</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#10-%E4%B8%89%E7%A7%8DJVM"><span class="post-toc-text">10.三种JVM</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#11-%E5%A0%86"><span class="post-toc-text">11.堆</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E6%96%B0%E7%94%9F%E5%8C%BA-%EF%BC%88%E6%BB%A1%E4%BA%86-%E8%BD%BBGC%EF%BC%89"><span class="post-toc-text">1.新生区 （满了 轻GC）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E8%80%81%E5%B9%B4%E5%8C%BA-%EF%BC%88%E6%BB%A1%E4%BA%86-%E9%87%8DGC%EF%BC%89"><span class="post-toc-text">2.老年区 （满了 重GC）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98"><span class="post-toc-text">堆内存调优</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MAT-Jprogiler%E4%BD%9C%E7%94%A8"><span class="post-toc-text">MAT,Jprogiler作用:</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#jprofiler%E4%BD%BF%E7%94%A8"><span class="post-toc-text">jprofiler使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#12-GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="post-toc-text">12.GC:垃圾回收</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#GC-%E4%BD%9C%E7%94%A8%E5%8C%BA%E5%9F%9F-%E5%A0%86-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="post-toc-text">GC:作用区域 堆+方法区</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#GC%E9%A2%98%E7%9B%AE"><span class="post-toc-text">GC题目</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#13-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="post-toc-text">13.常用算法</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#14-JMM"><span class="post-toc-text">14.JMM</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#15-volilate"><span class="post-toc-text">15 volilate</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="post-toc-text">1、概念</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#16-CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="post-toc-text">16 CAS底层原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5-1"><span class="post-toc-text">1、概念</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8"><span class="post-toc-text">2、代码使用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3%E3%80%81CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="post-toc-text">3、CAS底层原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4%E3%80%81CAS-%E7%BC%BA%E7%82%B9"><span class="post-toc-text">4、CAS 缺点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5%E3%80%81-%E6%80%BB%E7%BB%93"><span class="post-toc-text">5、 总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#17%E3%80%81%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98"><span class="post-toc-text">17、原子类AtomicInteger的ABA问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1%E3%80%81%E8%BF%9E%E7%8E%AF%E5%A5%97%E8%B7%AF"><span class="post-toc-text">1、连环套路</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3ABA%E9%97%AE%E9%A2%98"><span class="post-toc-text">2、解决ABA问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#18%E3%80%81Collection%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B"><span class="post-toc-text">18、Collection线程不安全的举例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="post-toc-text">多线程环境</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="post-toc-text">解决方案</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AVector"><span class="post-toc-text">方案一：Vector</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9ACollections-sychronized"><span class="post-toc-text">方案二：Collections.sychronized()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E9%87%87%E7%94%A8JUC%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="post-toc-text">方案三：采用JUC里面的方法</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#19%E3%80%81Java-%E7%9A%84%E9%94%81"><span class="post-toc-text">19、Java 的锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="post-toc-text">公平锁和非公平锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="post-toc-text">概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="post-toc-text">公平锁</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="post-toc-text">非公平锁</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA"><span class="post-toc-text">如何创建</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="post-toc-text">两者区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="post-toc-text">题外话</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E9%80%92%E5%BD%92%E9%94%81-ReentrantLock"><span class="post-toc-text">可重入锁(递归锁)ReentrantLock</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="post-toc-text">概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="post-toc-text">作用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="post-toc-text">自旋锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="post-toc-text">概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="post-toc-text">优缺点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%EF%BC%88%E5%86%99%E9%94%81%EF%BC%89-%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%88%E8%AF%BB%E9%94%81%EF%BC%89-%E4%BA%92%E6%96%A5%E9%94%81"><span class="post-toc-text">独占锁（写锁） &#x2F; 共享锁（读锁） &#x2F; 互斥锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="post-toc-text">概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%86%99%E9%94%81%E5%92%8C%E8%AF%BB%E9%94%81"><span class="post-toc-text">为什么会有写锁和读锁</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20%E3%80%81CountDownLatch-CyclicBarrier-Semaphore"><span class="post-toc-text">20、CountDownLatch_CyclicBarrier_Semaphore</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CountDownLatch"><span class="post-toc-text">CountDownLatch</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="post-toc-text">概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="post-toc-text">场景</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CyclicBarrier"><span class="post-toc-text">CyclicBarrier</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A6%82%E5%BF%B5-5"><span class="post-toc-text">概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="post-toc-text">案例</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Semaphore%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="post-toc-text">Semaphore：信号量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A6%82%E5%BF%B5-6"><span class="post-toc-text">概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="post-toc-text">代码</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#21%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="post-toc-text">21、阻塞队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A6%82%E5%BF%B5-7"><span class="post-toc-text">概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%98%9F%E5%88%97"><span class="post-toc-text">队列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="post-toc-text">阻塞队列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%EF%BC%9F"><span class="post-toc-text">为什么要用？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81BlockingQueue"><span class="post-toc-text">为什么需要BlockingQueue</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BlockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%98%AF%E5%B1%9E%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%BA%95%E4%B8%8B%E6%9C%89%E4%B8%83%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="post-toc-text">BlockingQueue阻塞队列是属于一个接口，底下有七个实现类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BlockingQueue%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="post-toc-text">BlockingQueue核心方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SynchronousQueue"><span class="post-toc-text">SynchronousQueue</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%94%A8%E5%A4%84"><span class="post-toc-text">阻塞队列的用处</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">生产者消费者模式</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#22%E3%80%81synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">22、synchronized和lock的区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1%E3%80%81%E5%8E%9F%E5%A7%8B%E6%9E%84%E6%88%90"><span class="post-toc-text">1、原始构成</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="post-toc-text">2、使用方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3%E3%80%81%E7%AD%89%E5%BE%85%E6%98%AF%E5%90%A6%E5%8F%AF%E4%B8%AD%E6%96%AD"><span class="post-toc-text">3、等待是否可中断</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4%E3%80%81%E5%8A%A0%E9%94%81%E6%98%AF%E5%90%A6%E5%85%AC%E5%B9%B3%E9%94%81"><span class="post-toc-text">4、加锁是否公平锁</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5%E3%80%81%E9%94%81%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6Condition"><span class="post-toc-text">5、锁绑定多个条件Condition</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#23%E3%80%81HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="post-toc-text">23、HashMap底层实现原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap-%E6%98%AF%E5%9F%BA%E4%BA%8E-hashing-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="post-toc-text">HashMap 是基于 hashing 的原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%85%B7%E4%BD%93%E7%9A%84-put-%E8%BF%87%E7%A8%8B%EF%BC%88JDK1-8%EF%BC%89"><span class="post-toc-text">以下是具体的 put 过程（JDK1.8）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%85%B7%E4%BD%93-get-%E8%BF%87%E7%A8%8B"><span class="post-toc-text">以下是具体 get 过程</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#24%E3%80%81ConcurrentHashMap"><span class="post-toc-text">24、ConcurrentHashMap</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Put"><span class="post-toc-text">Put</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#get-%E9%80%BB%E8%BE%91%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%EF%BC%9A"><span class="post-toc-text">get 逻辑比较简单：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JDK1-8-%E5%90%8E%E7%9A%84%E6%9B%B4%E6%94%B9"><span class="post-toc-text">JDK1.8 后的更改</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Put-1"><span class="post-toc-text">Put</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Get"><span class="post-toc-text">Get</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#25%E3%80%81ThreadLocal"><span class="post-toc-text">25、ThreadLocal</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1%E3%80%81ThreadLocal%E7%AE%80%E4%BB%8B"><span class="post-toc-text">1、ThreadLocal简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2%E3%80%81ThreadLocal%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="post-toc-text">2、ThreadLocal简单使用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3%E3%80%81ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="post-toc-text">3、ThreadLocal的实现原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4%E3%80%81%E4%BB%8EThreadLocalMap%E7%9C%8BThreadLocal%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="post-toc-text">4、从ThreadLocalMap看ThreadLocal使用不当的内存泄漏问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="post-toc-text">1、基础概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2%E3%80%81%E5%88%86%E6%9E%90ThreadLocalMap%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">2、分析ThreadLocalMap内部实现</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#26%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">26、线程池</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1%E3%80%81%E5%89%8D%E8%A8%80"><span class="post-toc-text">1、前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2%E3%80%81Callable%E6%8E%A5%E5%8F%A3"><span class="post-toc-text">2、Callable接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3%E3%80%81%E6%B3%A8%E6%84%8F"><span class="post-toc-text">3、注意</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4%E3%80%81ThreadPoolExecutor"><span class="post-toc-text">4、ThreadPoolExecutor</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">为什么用线程池</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="post-toc-text">线程池的好处</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="post-toc-text">架构说明</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">创建线程池</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">5、底层实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0"><span class="post-toc-text">线程池的重要参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BD%93%E8%90%A5%E4%B8%9A%E7%AA%97%E5%8F%A3%E5%92%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%AD%E9%83%BD%E6%BB%A1%E4%BA%86%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="post-toc-text">当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="post-toc-text">拒绝策略</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="post-toc-text">线程池底层工作原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="post-toc-text">为什么不用默认创建的线程池？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">手写线程池</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%90%88%E7%90%86%E5%8F%82%E6%95%B0"><span class="post-toc-text">线程池的合理参数</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#27%E3%80%81Hystrix"><span class="post-toc-text">27、Hystrix</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Hystrix%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="post-toc-text">Hystrix重要概念：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AE%EF%BC%9A"><span class="post-toc-text">配置项目：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="post-toc-text">服务熔断</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#28%E3%80%81spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="post-toc-text">28、spring循环依赖</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/06/17/Mybatis/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          Mybatis
        
      </span>
    </a>
  
  
    <a href="/2020/05/14/SpringBoot/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">SpringBoot</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 ZhangLichao<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://zhanglc1998.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/life/">life</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/Mysql/" style="font-size: 13.33px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 20px;">SpringCloud</a> <a href="/tags/SpringMvc/" style="font-size: 10px;">SpringMvc</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/welcome/" style="font-size: 10px;">welcome</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>首页</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>归档</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>关于我</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/Mysql/" style="font-size: 13.33px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Nodejs/" style="font-size: 10px;">Nodejs</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 20px;">SpringCloud</a> <a href="/tags/SpringMvc/" style="font-size: 10px;">SpringMvc</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/welcome/" style="font-size: 10px;">welcome</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>